BodyOp Bgeo-Read
|*<h3> Overview</h3>
Bgeo-Read is a body operator that let you use Houdini's binary geometry format Bgeo 
to import meshes and particles. In Houdini, you can explicitly add your own 
custom attributes per Point, Vertex or Primitive and they will be imported together 
with the body into different shape channels. 
<h3> Rules</h3>
When exporting from Houdini, there are 
some general rules that must be followed in order to get this operator to work: 
<ul>
<li>If exporting a mesh, each polygon MUST contain 3 vertices.</li>
<li>You can NOT mix sets of particles and polygons in a single Bgeo file. Export them separately.</li>
<li>Do NOT use the '$' character when naming your custom made attributes (more on this can be read below).</li>
<li>You can only add custom attributes of the types: float, int and vector (i.e String, Char and Index is not supported)</li>
<li>When using float or int for a custom attribute, only one or three elements can be used (e.g a custom attribute of 2 or 4 floats will NOT work)</li> 
</ul>

<h3> Custom attributes</h3>
    In the Attributes Include Lists you enter the names of the attributes you want to import. The '*' will include all attributes available. Use white space
    to distinguish between different attributes. If you export an attribute with 3 floats, this attribute will be renamed in Naiad with
    the prefix '$3f' (we might figure out something else in future versions). This is so Naiad can see the difference between a "3 float" 
    and a vector attribute. However, you do NOT need to enter any prefix when you write the names in these include lists.
<h3> Not Supported</h3>
At the moment, the following parameters are <u>ignored</u> in the Bgeo-Read operator:
<ul>
<li>Point Groups</li>
<li>Primitive Groups</li>
<li>Detail attributes (you can't export your own detail attributes)</li>
</ul>*|
{   
    Category "File"
	EnumGroup BodySignature{
	"Mesh"
	"Particle"	
	}

    ParamSection "Import Settings"
    {
	FileName "Filename" "filename.#.bgeo"
	|* Name of the Bgeo file. # will be interpreted as the current frame (set Frame Padding to fit your export settings) *|

	Int "Frame Padding" "4"
	|* The number of zeroes to padding the frame number by, when expanding to the absolute Bgeo filename. *|

	BodyName "Body Name" "bgeo-body"
	|*  *|

	BodySignature "Body Signature" "Mesh"
	|*The Body Signature decides if your imported Bgeo file should be treated as a Mesh or Particle 
	body. If the Mesh Body Signature is selected, the Bgeo-Read operator takes for granted that the 
	Bgeo file contains data about primitives. If a Mesh was exported from Houdini and the Particle 
	Body Signature is selected, all points will be treated as particles. *|

	Toggle "Integrity Check" "On"
	|*As stated earlier, each polygon must have 3 and only 3 vertices. The Integrity check option 
	adds an extra control when loading a Bgeo that verifies that every primtive is a triangle. 
	If you are certain that your mesh only contains triangles, you can skip this option and get 
	a slightly(roughly 5%) faster import process. This option does nothing if you have chosen the
	a Particle as Body Signature*|
    }

    ParamSection "Attributes Include Lists"
    {
	String "Point" "*"
	||See <i>Custom Attributes</i>
	String "Primitive" "*"
	||See <i>Custom Attributes</i>
	String "Vertex" "*"	
	|*Vertex attributes are stored in the TriangleShape channels. To see the difference between a Vertex attribute and a Primitive attribute,
	the vertex attributes get the prefix $v. Since the channels in Naiad have no support for storing Vectors of size 9, vertex attributes with
	multiple values (3 float, 3 int or a vector) will be split into different channels with prefixes $v0 $v1 and $v2. That prefix clarifies what
	vertex the data belongs to. As with the other prefix, you do NOT need to enter any prefix when you write the names in this include list.  *|
    }

    ParamSection "Tile Layout"
    {
	Float "Cell Scale" "1"
	|* Amount to scale the dimensions of the cells in the tile layout by. Note that this parameter does not represent the actual worldspace dimensions
	 of the cells, rather it uniformly scales them. To find out the actual worldspace dimensions you have to multiply this parameter by the 
	 global parameter "Master Cell Size". This allows you to set a global cell size in worldspace units for the whole simulation (the "Master Cell 
	 Size"), and still allow each body to have its own cell-size by changing this parameter. If you later decide to globally uprez the simulation, 
	 you don't have to find every "Cell Scale" parameter on all the BodyOps that have it, but simply change the "Master Cell Size". *|
	Int   "Tile Size"  "9"
	||The number of cells along each dimension of each tile in the volume
    }
    
    Single(Body) Output "body-output" 
}